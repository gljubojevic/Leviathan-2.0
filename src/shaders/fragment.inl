#pragma data_seg(".shader")
static const char* fragment = \
"#version 130\n"
"uniform int m;\n"
"out vec4 o;\n"
"float PI = 3.1416;\n"
"float t = m/44100.0;\n"
"float rep = 2.0;\n"
"float dist = 18.0;\n"
"float scene = 0;\n"
"float brg = 1.48;\n"
"float ap1 = 23.0;\n"
"float ap2 = 35.0;\n"
"float hash(float c){return fract(sin(dot(c, 12.9898)) * 43758.5453);}\n"
"mat3 rx(float a){return mat3(1.0,0.0,0.0,0.0,cos(a),-sin(a),0.0,sin(a),cos(a));}\n"
"mat3 ry(float a){return mat3(cos(a),0.0,sin(a),0.0,1.0,0.0,-sin(a),0.0,cos(a));}\n"
"mat3 rz(float a){return mat3(cos(a),-sin(a),0.0,sin(a),cos(a),0.0,0.0,0.0,1.0);}\n"
"float box(vec3 p, vec3 b)\n"
"{\n"
	"return max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n"
"}\n"
"float modp(inout vec2 p, float rep) {\n"
	"float angle = 2*PI/rep;\n"
	"float a = atan(p.y, p.x) + angle/2;\n"
	"float c = floor(a/angle);\n"
	"a = mod(a,angle) - angle/2.;\n"
	"p = vec2(cos(a), sin(a))*length(p);\n"
	"if (abs(c) >= (rep/2)) c = abs(c);\n"
	"return c;\n"
"}\n"
"vec2 mod2(inout vec2 p, vec2 size) {\n"
	"vec2 c = floor((p + size*0.5)/size);\n"
	"p = mod(p + size*0.5,size) - size*0.5;\n"
	"return c;\n"
"}\n"
"float sp(vec3 p, float r)\n"
"{\n"
	"return length(p)-r;\n"
"}\n"
"float caps(vec3 p, float r, float c){\n"
	"return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n"
"}\n"
"float map(vec3 p)\n"
"{\n"
	"if( scene < 1 ){\n"
		"float d = (p.y);\n"
		"vec2 r = mod2(p.zx, vec2(dist));\n"
		"modp(p.zx, rep);\n"
		"d = min(d, box((p-vec3(0.,1,9)), vec3(9,9,0.2)) );\n"
		"d = min(d, box((p-vec3(-6,1,0)), vec3(0.2,9.,9)) );\n"
		"d = min(d, box((p-vec3(6,1,-9)), vec3(0.2,9.,9)) );\n"
		"d = max(d, -box((p-vec3(0,4,0)), vec3(1.5,4.,10)));\n"
		"return d;\n"
	"}\n"
	"else\n"
	"{\n"
		"p += vec3(-70,0,0);\n"
		"vec3 q = p;\n"
		"modp(p.xz, 4.0);\n"
		"vec3 o = p;\n"
		"mod2(o.yx, vec2(6,9));\n"
		"vec3 r = p;\n"
		"float d = caps(p-vec3(rep,-3,0), 44.0, dist);\n"
		"mod2(r.xz, vec2(12.7));\n"
		"float d2 = box((o-vec3(0.,1,0)), vec3(9,1.5,ap1));\n"
		"d2 = max(d2, p.y-28.0);\n"
		"d = max(d, -d2);\n"
		"d = min(d, box((r-vec3(0.,8,0)), vec3(.6,9,.6)));\n"
		"d = max(d, -caps(p-vec3(rep,-3,0), 24.0, 15.0));\n"
		"float d6 = sp(p-vec3(rep,40,0), 30.0 );\n"
		"d = max(d, -d6);\n"
		"float d3 = caps(q-vec3(0,-3,0), 55.0, 0.0);\n"
		"d3 = max(d3, -caps(q-vec3(0,-3,0), ap2, 15.0));\n"
		"d3 = max(d3, -sp(q-vec3(0,40,0), 30.0 ));\n"
		"d = max(d, d3);\n"
		"return min(d, p.y);\n"
	"}\n"
"}\n"
"vec3 rhs(vec3 dir, float i)\n"
"{\n"
	"vec2 rnd = vec2(hash(i+1.), hash(i+2.));\n"
	"float s = rnd.x*PI*2.;\n"
	"float t = rnd.y*2.-1.;\n"
	"vec3 v = vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n"
	"return v * sign(dot(v, dir));\n"
"}\n"
"float ao( vec3 p, vec3 n, float maxDist, float falloff)\n"
"{\n"
	"float ao = 0.0;\n"
	"for( int i=0; i<10; i++ )\n"
	"{\n"
		"float l = hash(float(i))*maxDist;\n"
		"vec3 rd = normalize(n+rhs(n, l )*0.95)*l;\n"
		"ao += (l - map( p + rd )) / pow(1.+l, falloff);\n"
	"}\n"
	"return clamp(1.-ao*0.1,0.0,999.0);\n"
"}\n"
"vec3 shade( vec3 p, vec3 n, vec3 org, vec3 dir, vec2 v )\n"
"{\n"
	"return vec3(0.8)*sqrt(mix(ao(p,n, 8., 0.97), ao(p,n, 2., 0.9), 0.4));\n"
"}\n"
"vec3 normal( vec3 p )\n"
"{\n"
	"vec3 eps = vec3(0.001, 0.0, 0.0);\n"
	"return normalize( vec3(\n"
		"map(p+eps.xyy)-map(p-eps.xyy),\n"
		"map(p+eps.yxy)-map(p-eps.yxy),\n"
		"map(p+eps.yyx)-map(p-eps.yyx)\n"
	"));\n"
"}\n"
"vec3 mr( vec3 ro, vec3 rd, vec2 nfplane, out float f)\n"
"{\n"
	"vec3 p = ro+rd*nfplane.x;\n"
	"float t = 0.;\n"
	"for(int i=0; i<40; i++)\n"
	"{\n"
		"float d = map(p);\n"
		"t += d;\n"
		"p += rd*d;\n"
		"if( d < 0.01 || t > nfplane.y )\n"
			"break;\n"
	"}\n"
	"f = 0.04*sqrt(nfplane.y/max(9.0, distance(ro, p)));\n"
	"return p;\n"
"}\n"
"vec3 rm( vec3 ro, vec3 rd, vec2 nfplane )\n"
"{\n"
	"vec3 p = ro+rd*nfplane.x;\n"
	"float t = 0.;\n"
	"for(int i=0; i<80; i++)\n"
	"{\n"
		"float d = map(p);\n"
		"t += d;\n"
		"p += rd*d;\n"
		"if( d < 0.01 || t > nfplane.y )\n"
			"break;   \n"
	"}\n"
	"return p;\n"
"}\n"
"vec3 cc(vec3 c)\n"
"{\n"
	"return 0.08+0.94*pow(-0.5+1.7*pow(c,vec3(1.6)), vec3(0.6));\n"
"}\n"
"void main()\n"
"{\n"
	"vec2 res = vec2(1280,720);\n"
	"vec2 q = gl_FragCoord.xy/res.xy;\n"
	"vec2 v = -1.0+2.0*q;\n"
	"v.x *= res.x/res.y;\n"
	"vec3 ro = vec3(0);\n"
	"vec3 rd = vec3(0);\n"
	"if(t < 4){\n"
		"o = vec4(0.035*hash(length(q)*t));\n"
		"return;\n"
	"} else if(t < 9.0) {\n"
		"ro = vec3( 90.0+t,90.0,-130.0+t );\n"
		"rd = normalize( vec3(v.x, v.y, 8.0))*rx(1.)*ry(.5);\n"
		"rep = 6.0;\n"
		"dist = 13.9;\n"
	"} else if(t < 16){\n"
		"ro = vec3( 90.0,90.0,-130.0+t );\n"
		"rd = normalize( vec3(v.x, v.y, 8.0))*rx(1.)*ry(.5);\n"
		"rep = 8.0;\n"
		"dist = 16.0;\n"
	"} else if(t < 26){\n"
		"ro = vec3( 90.0+t,90.0,-130.0+t*0.1 );\n"
		"rd = normalize( vec3(v.x, v.y, 8.0))*rx(1.)*ry(.5);\n"
	"}\n"
	"else if(t < 32){\n"
		"ro = vec3( 90.0+t,90.0,-130.0 );\n"
		"rd = normalize( vec3(v.x, v.y, 5.0))*rx(PI/2.);\n"
	"}\n"
	"else if(t < 35){\n"
		"ro = vec3( 90.0+t,90.0,-130.0+t );\n"
		"rd = normalize( vec3(v.x, v.y, 8.0))*rx(1.)*ry(.5);\n"
		"rep = 6.0;\n"
		"dist = 11.9;\n"
	"}\n"
	"else if(t < 44){\n"
		"ro = vec3( 90.0-t*0.1,90.0,-130.0+t );\n"
		"rd = normalize( vec3(v.x, v.y, 8.0))*rx(1.)*ry(.5);\n"
		"rep = 6.0;\n"
		// this line was in the original shader but there's no variably y???
		// dunno, i don't notice a difference so i'll just leave it out...
		//"brg = 2.48-smoothstep(33,41,y);\n"
	"}\n"
	"else if(t < 49.5){\n"
		"ro = vec3( 90.0+t*.5,40.0,-130.0+t*2 );\n"
		"rd = normalize( vec3(v.x, v.y, 4.0))*rx(.5)*ry(-.2);\n"
		"rep = 6.0;\n"
		"dist = 21.0;\n"
		"brg = 1.6;\n"
	"}\n"
	"else if(t < 58){\n"
		"ro = vec3( 90.0+t,90.0,-130.0+t*0.1 );\n"
		"rd = normalize( vec3(v.x, v.y, 8.0))*rx(1.)*ry(.5);\n"
		"rep = 8.0;\n"
	"}\n"
	"else if(t < 69){\n"
		"ro = vec3(t*.5,90.0,-t*.5 );\n"
		"rd = normalize( vec3(v.x, v.y, 5.0))*rx(PI/2.)*ry(t*.01);\n"
		"rep = 6.0;\n"
		"dist = 16.0 - 3.0*smoothstep(21,30,t*.4);\n"
	"}\n"
	"else if(t < 75){\n"
		"float tt = t-69;\n"
		"ro = vec3( 0,290+tt*2,-tt*3);\n"
		"rd = normalize( vec3(v.x, v.y, 8.0) )*ry(1.2)*rx(1.5-0.01*tt)*rz(-1);\n"
		"rep = 0.0;\n"
		"dist = -26+43*smoothstep(70,82,t);\n"
		"scene = 1;\n"
		"brg = 1.4;\n"
	"}\n"
	"else if(t < 81){\n"
		"float tt = t-75;\n"
		"ro = vec3( 90.0-tt*3,210-tt,160-tt);\n"
		"rd = normalize( vec3(v.x, v.y, 5.0) )*ry(3.1-(t-73)*0.01)*rx(-.9);\n"
		"rep = 0.0;\n"
		"dist = -26+43*smoothstep(70,82,t);\n"
		"scene = 1;\n"
	"}\n"
	"else if(t < 98){\n"
		"float tt = t-80;\n"
		"ro = vec3( t,290-t,240-t);\n"
		"rd = normalize( vec3(v.x, v.y, 5.0) )*ry(3.1+tt*0.003)*rx(-.9);\n"
		"rep = 60.0;\n"
		"dist = 17.0;\n"
		"ap2 = 58-19*smoothstep(75,95,t)-12*smoothstep(85,96,t);\n"
		"ap1 = 9+19*smoothstep(80,95,t);\n"
		"scene = 1;\n"
	"}\n"
	"else if(t < 105){\n"
		"ro = vec3( 90.0+t,90.0,-130.0+t );\n"
		"rd = normalize( vec3(v.x, v.y, 8.0))*rx(1.)*ry(.5);\n"
		"rep = 6.0;\n"
		"dist = 11.9;\n"
	"}\n"
	"else if(t < 190){\n"
		"ro = vec3( 90.0+t,90.0,-130.0+t*0.1 );\n"
		"rd = normalize( vec3(v.x, v.y, 8.0))*rx(1.)*ry(.5);\n"
		"brg = 1.48+1.5*smoothstep(111,140,t);\n"
	"}\n"
	"vec3 p = rm(ro, rd, vec2(1., 545.) );\n"
	"vec3 n = normal(p.xyz);\n"
	"vec3 col = shade(p, n, ro, rd, q);\n"
	"vec3 rp = vec3(0);"
	"float tile = 1.0;"//ceil(sin(p.x*0.9)*cos(p.z*0.05));"
	"if(p.y < 26.0){\n"
		// uhh, stuff...
		//normalize(n+(1.0-tile)*0.1*vec3(hash(dot(p,p)),hash(length(p)),hash(dot(p,-p)) ))
		"float f;\n"
		"rp = mr(p, reflect(rd, n), vec2(0.1, 300.), f );\n"
		"vec3 rn = normal(rp.xyz);\n"
		"col += shade(rp, rn, ro, rd, q)*f; \n"
		"col *= 0.8;\n"
	"} else {\n"
		"col = mix(col,0.5+0.5*vec3(col*dot(n, normalize(p-vec3(99,-99,0)))), 0.3);\n"
	"}\n"
	"col = pow(col*brg/sqrt(2.+dot(v*0.3,v*0.3)), vec3(1./2.2));\n"
	"o = vec4(cc(col-0.035*hash(length(q)*t)), p.y<0.1?tile*distance(p, rp)/10.0:0.0 );\n"
"}";